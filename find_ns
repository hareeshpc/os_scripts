#!/bin/bash
#
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
#
# ARG_OPTIONAL_SINGLE([dhcp],[],[<Use dhcp instead of default router>])
# ARG_OPTIONAL_SINGLE([backup],[],[<Go to backup <index> instead of active>])
# ARG_OPTIONAL_BOOLEAN([container],[],[<Go to container instead of namespace>])
# ARG_POSITIONAL_SINGLE([name],[<name of object, typically router id or subnet name for dhcp>],[])
# ARG_HELP([<The general help message of my script>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.4.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

# When called,the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes',the usage is print to stderr (prior to )
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue,have to supply file as an argument,got '$_arg_infile'" 4

## Sourcing execution libraries
source logger.sh
source ns_functions

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

# Function that evaluates whether a value passed to it
# begins by a character that is a short option of an argument
# the script knows about
begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='h'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
# The positional args array has to be reset before the parsing,because it may already be defined
# - for example if this script is sourced by an argbash-powered script.
_positionals=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_dhcp=
_arg_backup=
_arg_container=off

# Function that prints general usage of the script.
# This is useful if users asks for it,or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help ()
{
	echo "<The general help message of my script>"
	printf 'Usage: %s [--dhcp <arg>] [--backup <arg>] [--(no-)container] [-h|--help] <name>\n' "$0"
	printf "\t%s\n" "<name>: <name of object, typically router id or subnet name for dhcp>"
	printf "\t%s\n" "--dhcp: <Use dhcp instead of default router> (no default)"
	printf "\t%s\n" "--backup: <Go to backup <index> instead of active> (no default)"
	printf "\t%s\n" "--container,--no-container: <Go to container instead of namespace> (off by default)"
	printf "\t%s\n" "-h,--help: Prints help"
}

# THE PARSING ITSELF
while test $# -gt 0
do
	_key="$1"
	# We now iterate through all passed arguments.
	# When dealing with optional arguments:
	# We support both whitespace or = as a delimiter between option argument and its value.
	# Therefore, we expect --opt=value, --opt value or -o value
	# so we watch for --opt=*, --opt and -o
	# For whatever we get, we strip '--opt=' using the ${var##...} notation.
	# if nothing got stripped, we know that we got the long or short option
	# so we reach out for the next argument.
	# At the end, either of what was successful is stored as the result.
	case "$_key" in
		--dhcp|--dhcp=*)
			_val="${_key##--dhcp=}"
			if test "$_val" = "$_key"
			then
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_val="$2"
				shift
			fi
			_arg_dhcp="$_val"
			;;
		--backup|--backup=*)
			_val="${_key##--backup=}"
			if test "$_val" = "$_key"
			then
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_val="$2"
				shift
			fi
			_arg_backup="$_val"
			;;
		--no-container|--container)
			_arg_container="on"
			test "${1:0:5}" = "--no-" && _arg_container="off"
			;;
		-h*|--help)
			print_help
			exit 0
			;;
		*)
			_positionals+=("$1")
      FIND_ROUTER_ID_FROM_NAME ${_positionals[0]}
      FIND_ACTIVE_HOST_FOR_ROUTER ${ROUTER_ID}
      FIND_L3AGENT_CONTAINER_NAME ${ACTIVE_HOST_NAME}
      INSIDE_NAMESPACE
			;;
	esac
	shift
done

# We have an array of variables to which we want to save positional args values.
# This array is able to hold array elements as targets.
_positional_names=('_arg_name' )
# Now check that we didn't receive more or less of positional arguments than we require.
_required_args_string="'name'"
test ${#_positionals[@]} -lt 1 && _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
test ${#_positionals[@]} -gt 1 && _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
# Take arguments that we have received,and save them in variables of given names.
# The 'eval' command is needed as the name of target variable is saved into another variable.
for (( ii = 0; ii < ${#_positionals[@]}; ii++))
do
	eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
done

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# echo "Value of --option: $_arg_option"
# echo "print is $_arg_print"
# echo "Value of positional-arg: $_arg_positional_arg"

# ] <-- needed because of Argbash
